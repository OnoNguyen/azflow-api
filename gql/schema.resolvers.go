package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"azflow-api/azure/auth"
	"azflow-api/domain/story"
	"azflow-api/gql/model"
	"azflow-api/openai"
	"context"
	"fmt"
	"math/rand"
	"path/filepath"
	"time"
)

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input *model.SignupInput) (int, error) {
	member, err := auth.GetMember(ctx)

	if err != nil {
		return 0, err
	}

	return member.Signup()
}

// CreateAudio is the resolver for the createAudio field.
func (r *mutationResolver) CreateAudio(ctx context.Context, input model.AudioInput) (*model.Audio, error) {
	member, err := auth.GetMember(ctx)
	if err != nil {
		return nil, err
	}

	return story.CreateAudio(member.Email, member.ExtId, input.Text, input.Voice, input.Title)
}

// CreateAllAudios is the resolver for the createAllAudios field.
func (r *mutationResolver) CreateAllAudios(ctx context.Context, input []*model.AudioInput) ([]*model.Audio, error) {
	// convert input to array of string and return
	fmt.Println(input)
	audios := make([]*model.Audio, 0, len(input))
	for _, p := range input {
		audios = append(audios, &model.Audio{Title: p.Title, URL: "https://azflow.io/s/123", ID: 123, TranscriptURL: "https://azflow.io/s/123"})
	}
	fmt.Println(audios)
	return audios, nil
}

// EditAudio is the resolver for the editAudio field.
func (r *mutationResolver) EditAudio(ctx context.Context, input model.EditAudioInput) (*model.Audio, error) {
	_, err := auth.GetMember(ctx)
	if err != nil {
		return nil, err
	}

	return story.EditAudio(input.ID, input.Title, input.Transcript)
}

// CreateBookSummary is the resolver for the createBookSummary field.
func (r *mutationResolver) CreateBookSummary(ctx context.Context, input *model.BookInput) (string, error) {
	_, err := auth.GetMember(ctx)
	if err != nil {
		return "", err
	}
	return "Chapter 5 of \"Zero to One\" by Peter Thiel focuses on the importance of monopolies in business. Thiel argues that the goal of every entrepreneur should be to create a monopoly, which he defines as a company that is so good at what it does that no other firm can offer a close substitute. He outlines several key characteristics of successful monopolies:\n\n1 **Unique Product:** Successful monopolies offer products or services that are fundamentally different from their competitors. This uniqueness allows them to command higher prices and greater customer loyalty.\n\n2 **Network Effects:** A company can benefit from network effects when its product becomes more valuable as more people use it. Examples include social media platforms and payment systems.\n\n3 **Economies of Scale:** Larger companies can often operate more efficiently and profitably as they grow. As they scale, their fixed costs are distributed over a larger customer base, leading to reduced average costs.\n\n4 **Branding:** A strong brand can serve as a barrier to entry for new competitors, as it fosters customer loyalty and recognition that is difficult for others to replicate.\n\nThiel emphasizes that competition is for losers, as it drives profits down and reduces the incentive for innovation. Instead, he encourages entrepreneurs to seek out opportunities where they can dominate a market and create products that no one else can mimic. By focusing on creating a monopoly, startups can generate sustainable profits and create significant long-term value.\n\nThe chapter concludes with the notion that while building a monopoly may seem counter to the principles of free market competition, itâ€™s essential for driving real innovation and advancement in society. Thiel advocates for a focus on creating unique value rather than merely competing for existing market share.", nil
	//return story.CreateBookSummary(input.Title)
}

// CreateShortURL is the resolver for the createShortURL field.
func (r *mutationResolver) CreateShortURL(ctx context.Context, longURL string) (*model.ShortURL, error) {
	id := generateID()
	shortURL := fmt.Sprintf("https://azflow.io/s/%s", id)

	shortLink := &model.ShortURL{
		ID:       id,
		LongURL:  longURL,
		ShortURL: shortURL,
	}

	ShortURLs[id] = shortLink

	return shortLink, nil
}

// GenerateImage is the resolver for the generateImage field.
func (r *mutationResolver) GenerateImage(ctx context.Context, input model.ImagePromptInput) (string, error) {
	return fmt.Sprintf("Prompt input: %v", input), nil

	openai.Init()
	id := fmt.Sprintf("%d", input.ID)
	workDir := filepath.Join("./", story.VideoWorkDir)

	if imagePath, err := openai.CreateImage(input.Prompt, fmt.Sprintf("%s/%s.png", workDir, id)); err != nil {
		return "", err
	} else {
		return fmt.Sprintf("Image has been generated at %s", imagePath), nil
	}

}

// GenerateAllImages is the resolver for the generateAllImages field.
func (r *mutationResolver) GenerateAllImages(ctx context.Context, input []*model.ImagePromptInput) ([]string, error) {
	// convert input to array of string and return
	fmt.Println(input)
	prompts := make([]string, 0, len(input))
	for _, p := range input {
		prompts = append(prompts, p.Prompt)
	}
	fmt.Println(prompts)
	return prompts, nil
}

// CreateVideoPreview is the resolver for the createVideoPreview field.
func (r *mutationResolver) CreateVideoPreview(ctx context.Context, input model.CreateVideoPreviewInput) (string, error) {
	return story.CreateVideoPreview(input.Images, input.ContentTrunks)
}

// CreateAudioTrunk is the resolver for the createAudioTrunk field.
func (r *mutationResolver) CreateAudioTrunk(ctx context.Context, input model.AudioTrunkInput) (string, error) {
	return story.CreateAudioTrunk(input.Text, input.Voice, input.ID)
}

// GetAudios is the resolver for the getAudios field.
func (r *queryResolver) GetAudios(ctx context.Context) ([]*model.Audio, error) {
	as, err := story.GetAudios("")

	if err != nil {
		return nil, err
	}

	audios := make([]*model.Audio, 0, len(as))
	for _, a := range as {
		b := model.Audio{Title: a.Title, URL: a.Url, ID: a.Id, TranscriptURL: a.TranscriptUrl}
		audios = append(audios, &b)
	}

	return audios, nil
}

// GetAudio is the resolver for the getAudio field.
func (r *queryResolver) GetAudio(ctx context.Context, id *int) (*model.Audio, error) {
	member, _ := auth.GetMember(ctx)

	if member == nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	a, err := story.GetAudio(*id)

	if err != nil {
		return nil, err
	}

	return &model.Audio{Title: a.Title, URL: a.Url, ID: a.Id, TranscriptURL: a.TranscriptUrl}, nil
}

// GetAudiosForMember is the resolver for the getAudiosForMember field.
func (r *queryResolver) GetAudiosForMember(ctx context.Context) ([]*model.Audio, error) {
	member, _ := auth.GetMember(ctx)

	if member == nil {
		return nil, fmt.Errorf("unauthenticated")
	}

	as, err := story.GetAudios(member.Email)

	if err != nil {
		return nil, err
	}

	audios := make([]*model.Audio, 0, len(as))
	for _, a := range as {
		b := model.Audio{Title: a.Title, URL: a.Url, ID: a.Id, TranscriptURL: a.TranscriptUrl}
		audios = append(audios, &b)
	}

	return audios, nil
}

// GetShortURL is the resolver for the getShortURL field.
func (r *queryResolver) GetShortURL(ctx context.Context, id string) (*model.ShortURL, error) {
	if link, ok := ShortURLs[id]; ok {
		return link, nil
	}
	return nil, fmt.Errorf("short link not found")
}

// GetLongURL is the resolver for the getLongURL field.
func (r *queryResolver) GetLongURL(ctx context.Context, shortURL string) (string, error) {
	for _, link := range ShortURLs {
		if link.ShortURL == shortURL {
			return link.LongURL, nil
		}
	}
	return "", fmt.Errorf("URL not found")
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func generateID() string {
	rand.Seed(time.Now().UnixNano())
	letters := []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
	b := make([]rune, 8)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

var ShortURLs = make(map[string]*model.ShortURL)
